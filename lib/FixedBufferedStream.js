// Generated by CoffeeScript 1.4.0
var BufferedStream, stream, util;

stream = require('stream');

util = require('util');

/*
`BufferedStream([size])`
========================

This class implement both the Readable and Writable Stream 
API. Data written to it are stored inside a buffer. The buffer 
is emited though a "data" event when it is about to 
get larger than a defined "size".

The buffer is defined with a fixed size. As a consequence, 
this implentation present the advantage of consuming a 
constant amount of memory over time.

In the event that the data written is larger than the 
defined size, the buffer mechanism is bypassed and the data 
is directly emited with the "data" event. 

Setting the "size" parameter to 0 will simply bypassed the bufferisation.

Performances
------------

The results presented below are obtained by running `coffee samples/speed.coffee`.

Writting 100000 lines of 100 bytes (about 95 Mo)
```
# 0 b     : 2 s 57 ms 
# 64 b    : 2 s 17 ms 
# 128 b   : 2 s 32 ms 
# 256 b   : 1 s 755 ms 
# 512 b   : 1 s 200 ms 
# 1 Kb    : 728 ms 
# 1 Mb    : 266 ms 
# 4 Mb    : 271 ms 
# 16 Mb   : 282 ms 
# 64 Mb   : 276 ms 
# 128 Mb  : 279 ms
```

Writting 1000000 lines of 100 bytes (about 95 Mo)
```
0 b     : 19 s 937 ms 
64 b    : 17 s 717 ms 
128 b   : 16 s 743 ms 
256 b   : 10 s 580 ms 
512 b   : 7 s 463 ms 
1 Kb    : 5 s 59 ms 
1 Mb    : 2 s 470 ms 
4 Mb    : 2 s 518 ms 
16 Mb   : 2 s 750 ms 
64 Mb   : 2 s 784 ms 
128 Mb  : 2 s 637 ms
```
*/


BufferedStream = function(size) {
  if (size == null) {
    size = 1024;
  }
  this.writable = true;
  this.readable = true;
  this.size = size;
  this.buffer = new Buffer(size);
  this.bufferPos = 0;
  return stream.call(this);
};

BufferedStream.prototype.__proto__ = stream.prototype;

BufferedStream.prototype.write = function(data) {
  var buffer, dataWritten;
  if (!Buffer.isBuffer(data)) {
    data = new Buffer(data);
  }
  if (data.length > this.size) {
    this.emit('data', data);
    return !this.paused;
  }
  dataWritten = Math.min(this.size - this.bufferPos, data.length);
  if (dataWritten !== 0) {
    data.copy(this.buffer, this.bufferPos, 0, dataWritten);
  }
  this.bufferPos += dataWritten;
  if (dataWritten !== data.length) {
    buffer = new Buffer(this.bufferPos);
    this.buffer.copy(buffer, 0, 0, this.bufferPos);
    this.emit('data', buffer);
    data.copy(this.buffer, 0, dataWritten, data.length);
    this.bufferPos = data.length - dataWritten;
    return !this.paused;
  }
  return true;
};

BufferedStream.prototype.pause = function(data) {
  return this.paused = true;
};

BufferedStream.prototype.resume = function(data) {
  this.paused = false;
  return this.emit('drain');
};

BufferedStream.prototype.end = function() {
  this.emit('data', this.buffer.slice(0, this.bufferPos));
  this.writable = false;
  this.readable = false;
  return this.emit('end');
};

module.exports = BufferedStream;
