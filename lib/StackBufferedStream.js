// Generated by CoffeeScript 1.4.0
var BufferStream, Stream, util;

util = require('util');

Stream = require('stream');

/*

Performances
------------

The results presented below are obtained by running `coffee samples/speed.coffee`.

Writting 100000 lines of 100 bytes (about 9.5 Mo)
```
0 b     : 2 s 105 ms 
64 b    : 2 s 226 ms 
128 b   : 2 s 205 ms 
256 b   : 1 s 294 ms 
512 b   : 771 ms 
1 Kb    : 548 ms 
1 Mb    : 344 ms 
4 Mb    : 345 ms 
16 Mb   : 326 ms 
64 Mb   : 322 ms 
128 Mb  : 329 ms
```

Writting 1000000 lines of 100 bytes (about 95 Mo)
```
0 b     : 21 s 122 ms 
64 b    : 21 s 345 ms 
128 b   : 21 s 156 ms 
256 b   : 12 s 224 ms 
512 b   : 7 s 344 ms 
1 Kb    : 5 s 237 ms 
1 Mb    : 3 s 76 ms 
4 Mb    : 3 s 138 ms 
16 Mb   : 3 s 186 ms 
64 Mb   : 3 s 380 ms 
128 Mb  : 3 s 314 ms
```
*/


BufferStream = function(size) {
  Stream.call(this);
  this.readable = true;
  this.writable = true;
  this.bufferSize = size != null ? parseInt(size, 10) : 1024 * 1024;
  this.paused = false;
  this.buffers = [];
  return this.stackSize = 1;
};

util.inherits(BufferStream, Stream);

/*
Emit "end" if the "end" function has been called and there is no more buffer to flush.
*/


BufferStream.prototype.flush = function() {
  var buffer, ended;
  ended = !this.writable;
  if (!ended && this.paused) {
    return;
  }
  if (!ended && this.buffers.length <= 1) {
    return this.emit('drain');
  }
  if ((ended && this.buffers.length) || this.buffers.length > 1) {
    buffer = this.buffers.shift();
    this.emit('data', buffer.slice(0, buffer.position));
  }
  if (ended && !this.buffers.length) {
    if (this.paused) {
      this.on('drain', function() {
        return this.emit('end');
      });
    } else {
      this.emit('end');
    }
    return;
  }
  return this.flush();
};

BufferStream.prototype.destroy = function() {
  return this.destroySoon();
};

BufferStream.prototype.destroySoon = function() {
  this.end();
  this.readable = false;
  return this.writable = false;
};

/*
Write API
drain  Emitted after a write() method was called that returned false to indicate that it is safe to write again
error  Emitted on error with the exception exception
close  Emitted when the underlying file descriptor has been closed
pipe    Emitted when the stream is passed to a readable stream's pipe method
*/


BufferStream.prototype.write = function(data, opt_encoding) {
  var buffer, encoding, flush;
  if (data) {
    flush = false;
    encoding = opt_encoding || 'utf8';
    if (!Buffer.isBuffer(data)) {
      data = new Buffer(data, encoding);
    }
    if (data.length > this.bufferSize) {
      this.emit('data', data);
      return !this.paused;
    }
    if (data.length > this.bufferSize) {
      throw new Error('Data length greater than buffer');
    }
    if (!this.buffers.length) {
      buffer = new Buffer(this.bufferSize);
      buffer.position = 0;
      this.buffers.push(buffer);
    } else {
      buffer = this.buffers[this.buffers.length - 1];
    }
    if (buffer.position + data.length > buffer.length) {
      buffer = new Buffer(this.bufferSize);
      buffer.position = 0;
      this.buffers.push(buffer);
      flush = true;
    }
    data.copy(buffer, buffer.position);
    buffer.position += data.length;
    if (flush) {
      this.flush();
    }
  }
  return this.buffers.length <= this.stackSize;
};

BufferStream.prototype.end = function(data, opt_encoding) {
  if (data) {
    this.write(data, opt_encoding);
  }
  this.writable = false;
  return this.flush();
};

/*
Read API
data    The 'data' event emits either a Buffer (by default) or a string if setEncoding() was used.
end    Emitted when the stream has received an EOF (FIN in TCP terminology). Indicates that no more 'data' events will happen. If the stream is also writable, it may be possible to continue writing.
error  Emitted if there was an error receiving data.
close  Emitted when the underlying file descriptor has been closed. Not all streams will emit this. (For example, an incoming HTTP request will not emit 'close'.)
*/


BufferStream.prototype.pause = function() {
  return this.paused = true;
};

BufferStream.prototype.resume = function() {
  this.paused = false;
  return this.flush();
};

module.exports = BufferStream;
